# spring, jpa practice
## jpa 학습내용 정리
  - orm 사용시 엔티티와 연관관계를 설계하는 방법을 익힌다.
  - ManyToMany 관계를 사용하기 보다는 중간 테이블 엔티티를 만들어서 OneToMany, ManyToOne 관계로 변경하자.
  - 가능한 모든 연관관계는 LAZY 로 설정하자. 예상 못하는 N+1 문제가 발생할 수 있기 때문이다.
  - 컬렉션은 필드에서 초기화 하는 것이 안전하다.  
  - 페치조인을 활용하여 쿼리를 최적화 할 수 있다.
  - 컬렉션일 경우 batchSize 옵션이나 dto를 jpql을 사용하여 가져오는 방식으로 페이징을 활용 할 수 있다.
  - 컬렉션 조회시 jpql 을 사용하여 쿼리를 최적화 한다.
    1. distinct 키워드를 사용해서 컬렉션 조회시 중복 id 를 제거할 수 있다.
    2. 컬렉션 페치조인(일대다)은 1개의 컬렉션에 대해서만 사용해야한다.
    3. 단점으로는 페이징을 할 수 없다.
    4. jqpl 페치조인과 페이징을 함께 사용하면 db 에서 처리할 수 없기 때문에 (db 와 객체의 차이 때문) 메모리에서 처리하는데 메모리가 터질 위험이 있다.
  - 페이징과 컬렉션 엔티티를 함께 사용하는 법
    1. ToOne(일대일,다대일) 관계는 모두 페치조인을 사용한다.
    2. 그 후, 컬렉션은 LAZY LOADING 을 활용한다.
    3. 지연로딩 성능 최적화를 위하여 globalBatchSize 를 설정하여 "IN" query 를 더한다.
  - CQRS 적용
    1. 조회시 사용하는 쿼리와 명령시 사용하는 쿼리를 분리하여 운영에 유리함을 가져간다.
  - OSIV(하이버네이트의 영속성컨텍스트) 와 성능 최적화 
    1. JPA는 트랜잭션이 시작하는 시점에 데이터베이스 커넥션을 가져온다. 반환 시점은 OSIV(open-session-in-view) 옵션이 true로 되어있으면 종료되도 반환을 하지 않고 false로 되어있으면 반환한다. 왜냐하면 트랜잭션이 종료되도 영속성 컨텍스트에서 지연로딩 기능을 사용할 수 있기 때문에 커넥션을 유지 하는 것이다. 주로 컨트롤러에서의 api의 요청이 반환될때 까지 유지되도록 한다.
    2. 하지만 영속성컨텍스트(데이터베이스커넥션)을 오랫동안 들고있으면 커넥션이 모자를 수 있고 이는 장애로 이어질 수 있다. 성능 최적화를 위하여 osiv 를 off 설정으로 한다면 반드시 트랜잭션 내에서 모든 지연로딩을 처리하거나 페치조인을 사용 해야한다.
    3. 성능최적화를 위해서 명령과 조회를 분리(CQRS) 하면 커넥션을 효율적으로 사용할 수 있다. 보통 서비스 레벨에서 @Transactional 을 관리하므로 요청수가 많은 실시간 api 는 osiv 를 끄고, 커넥션이 많이 필요하지 않은 서비스(ADMIN)는 true 로 사용하여 개발을 편히 할 수 있다.

